function drawGotoGame () {
	background(100);

let elapsed = millis() - gamePlayStartTime;
	timeLeft = maxTime - elapsed;

	if (timeLeft <= 0) {
		gameLostDueToTime = true;
		gameState = "endGame";
		gameResult = "lose";
		return;
	}

	// Timer display
	fill('white');
	textSize(24);
	textAlign(LEFT, TOP);
	text(`Time left: ${floor(timeLeft / 1000)}s`, 20, 20);

	// Top-down environment sections
	drawTopDownEnvironment();

	// Draw obstacles
	fill(255, 0, 0);
	for (let obs of obstacles) {
		rect(obs.x, obs.y, obs.w, obs.h);
	}

	// Draw stadium at top
	fill('blue');
	rect(width / 2 - 100, 0, 200, 50);
	fill('white');
	textAlign(CENTER, CENTER);
	textSize(20);
	text("STADIUM", width / 2, 25);

	// Draw player
	imageMode(CENTER);
	image(player, x, y, 50, 50);

	// Timer display
	fill('white');
	textSize(24);
	textAlign(LEFT, TOP);
	text(`Time left: ${floor(timeLeft / 1000)}s`, 20, 20);

	// Check win condition
	if (y < 50) {
		gameState = "black2";
		return;
	}

	// Check obstacle collisions
	for (let obs of obstacles) {
		// Move if type is car or log
		if (obs.type === "car" || obs.type === "log") {
			obs.x += obs.speed * obs.dir;

			// Wrap around screen
			if (obs.x > width + 50) obs.x = -obs.w;
			if (obs.x < -obs.w - 50) obs.x = width;
		}

		// Draw obstacle
		if (obs.type === "car") fill(255, 0, 0);
		else if (obs.type === "tree") fill(0, 150, 0);
		else if (obs.type === "log") fill(139, 69, 19);

		rect(obs.x, obs.y, obs.w, obs.h);

		// Collision check
		if (collideRectCircle(obs.x, obs.y, obs.w, obs.h, x, y, 40)) {
			gameResult = "lose";
			gameState = "endGame";
			return;
		}
	}
}

function drawTopDownEnvironment() {
	// House at bottom
	fill(180, 120, 80); // brown roof
	rect(width / 2 - 100, height - 180, 200, 150);
	fill(100, 50, 0); // door
	rect(width / 2 - 25, height - 30, 50, 30);

	// Lawn
	fill(34, 139, 34);
	rect(0, height - 300, width, 100);

	// Sidewalk
	fill(200);
	rect(0, height - 400, width, 50);

	// Street
	fill(60);
	rect(0, height - 550, width, 120);

	// Park
	fill(0, 100, 0);
	rect(0, height - 750, width, 150);

	// River
	fill('skyblue');
	rect(0, height - 950, width, 100);

	// Stadium
	fill('blue');
	rect(width / 2 - 100, height - 1050, 200, 50);
	fill('white');
	textAlign(CENTER, CENTER);
	textSize(20);
	text("STADIUM", width / 2, height - 1025);
}

function generateObstacles() {
	let obs = [];

	// Moving cars (left to right and right to left)
	for (let i = 0; i < 5; i++) {
		obs.push({
			x: random(0, width),
			y: height - 530 + random(-20, 60),
			w: 120,
			h: 40,
			speed: random(2, 4),
			dir: random([1, -1]),
			type: "car"
		});
	}

	// Static trees in park
	for (let i = 0; i < 6; i++) {
		obs.push({
			x: random(50, width - 100),
			y: height - 740 + random(0, 130),
			w: 50,
			h: 60,
			type: "tree"
		});
	}

	// Moving logs in river
	for (let i = 0; i < 4; i++) {
		obs.push({
			x: random(0, width),
			y: height - 940 + random(0, 60),
			w: 150,
			h: 30,
			speed: random(1.5, 3),
			dir: random([1, -1]),
			type: "log"
		});
	}

	return obs;
}

function collideRectCircle(rx, ry, rw, rh, cx, cy, diameter) {
	let testX = cx;
	let testY = cy;

	if (cx < rx) testX = rx;
	else if (cx > rx + rw) testX = rx + rw;

	if (cy < ry) testY = ry;
	else if (cy > ry + rh) testY = ry + rh;

	let distX = cx - testX;
	let distY = cy - testY;
	let distance = sqrt(distX * distX + distY * distY);

	return distance <= diameter / 2;
}
